    {% extends 'xgds_image/imageDashboardBase.html' %}

    {% block scripts %}
    {{ block.super }}
        <script type="text/javascript" src='{{ EXTERNAL_URL }}fabric.js/dist/fabric.min.js'></script>
        <script type="text/javascript" src='{{ EXTERNAL_URL }}openseadragon-fabricjsOverlay/openseadragon-fabricjs-overlay.js'></script>
    {#<script type="text/javascript" src='{{ EXTERNAL_URL }}openseadragon-annotations/dist/openseadragon-annotations.js'></script>#}
    {% endblock scripts %}
    {% block content %}
    <h1>Emigre Sandbox beta</h1>


    <div class="btn-group" data-toggle="buttons">
        <label class="btn btn-primary active">
            <input type="radio" name="cursorMode" id="navigateImage" autocomplete="off" value="navigateImage" checked>Navigate Image</label>
        <label class="btn btn-primary">
            <input type="radio" name="cursorMode" id="editAnnotations" autocomplete="off" value="editAnnotations">Edit Annotations</label>
    </div>

    </br>
    <div class="btn-group" data-toggle="buttons">
    <label class="btn btn-primary active">
        <input type="radio" name="annotationShape" id="text" autocomplete="off" value="text"checked>Text</label>
    <label class="btn btn-primary">
        <input type="radio" name="annotationShape" id="rectangle" autocomplete="off" value="rectangle">Rectangle</label>
    <label class="btn btn-primary">
        <input type="radio" name="annotationShape" id="circle" autocomplete="off" value="circle">Circle</label>

    </div>
    <button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off" id="addAnnotation">Add Annotation</button>

    <div id="openseadragon1" style="width: 800px; height: 600px;"></div>
    {% endblock content %}
        {% block jsInit %}

                  var prefixUrl = '/static/openseadragon/built-openseadragon/openseadragon/images/';
    var viewer = OpenSeadragon({
        id:            "openseadragon1",
        prefixUrl:     prefixUrl,
        showNavigator: true,
        gestureSettingsMouse:   {
            clickToZoom: false
        },
        clickToZoom: "false",
        tileSources:   [{
            Image:  {
                //Need to change [tile_format="jpg", image_quality=0.85,]
                //Plus any other changes in deepzoom.py we make
                xmlns: "http://schemas.microsoft.com/deepzoom/2009",
                Url: "../../../../data/images/spacePics/ISS044-E-1998_files/",
                TileSize: "128",
                Overlap: "2",
                Format: "png",
                ServerFormat: "Default",
                Size: {
                    Width: "4928",
                    Height: "3280",
                }
            }
        }],
    });

    //fabricjs-openseadragon annotation object
    var overlay = viewer.fabricjsOverlay();
    var line, rectangle, circle, ellipse, text, isDown, origX, origY;

    /* the mouse can be in 3 modes:
        1.) OSD (for interaction w/ OSD viewer, drag/scroll/zoom around the map
        2.) addAnnotation (disable OSD mode and enable click/drag on fabricJS canvas to draw an annotation)
        3.) editAnnotation (disable OSD mode and allow editing of existing annotations (but do not draw on clicK)
        getters and setters are below
     */
    var mouseMode = "OSD";

    addRectToCanvas(1000, 1000);

    //Euclidean distance between (x1,y1) and (x2,y2)
    function distanceFormula(x1, y1, x2, y2) {
        var xDist = Math.pow((x1-x2),2);
        var yDist = Math.pow((y1-y2),2);
        return Math.sqrt(xDist+yDist);
    }

    function initializeLine(x, y) {
        line = new fabric.Line([x, y, x, y], {
            left: x,
            top: y,
            stroke: "red",
            strokeWidth: 15,
            originX: 'center',
            originY: 'center'
        });
        overlay.fabricCanvas().add(line)
    }

    function updateLineEndpoint(x, y) {
        line.set({x2:x, y2:y});
    }

    function initializeEllipse(x, y) {
        ellipse = new fabric.Ellipse({
            left: x,
            top: y,
            radius: 1,
            strokeWidth: 1,
            stroke: 'black',
            fill: 'white',
            selectable: true,
            originX: 'center', originY: 'center'
        });
        overlay.fabricCanvas().add(ellipse);
    }

    function updateEllipse(x, y) {
        var distance = distanceFormula(x,y,origX,origY);

        ellipse.set({rx: Math.abs(origX-x), ry:Math.abs(origY-y)});
    }


    //TODO: Create overloaded initializeCircle function
    function initializeCircle(x, y) {
        circle = new fabric.Circle({
            left: x,
            top: y,
            radius: 1,
            strokeWidth: 1,
            stroke: 'black',
            fill: 'white',
            selectable: true,
            originX: 'center',
            originY: 'center'
        });
        overlay.fabricCanvas().add(circle);
    }

    //TODO: should I update the circle member variable automatically or pass in the object to modify?
    function updateCircleRadius(x, y, origX, origY) {
        var radius = distanceFormula(x, y, origX, origY);
        circle.set({radius: radius});
    }

    function initializeRectangle(x, y) {
        rectangle = new fabric.Rect({
            left: x,
            top: y,
            fill: 'blue',
            width: 1,
            height: 1
        });
        overlay.fabricCanvas().add(rectangle);
    }

    function updateRectangleWidth(x, y, origX, origY) {
        var width = Math.abs(x-origX);
        var height = Math.abs(y-origY);
        rectangle.set({width: width, height: height});
    }

    function initializeText(x, y) {
        text = new fabric.Text("hello world", {
            left: x,
            top: y
        });
        overlay.fabricCanvas().add(text);
    }

    function updateTextContent(x, y) {
        var width = Math.abs(x-origX);
        var height = Math.abs(y-origY);
        text.set({width: width, height: height})
    }

    /*
    Arrows are initialized in a strange way. Arrows aren't provided by fabricjs so you need to create them yourself. We do this by
    computing a group of points (in calculateArrowPoints()) and then creating a polygon that encloses all of those points (so we're
    really drawing a polygon, not an arrow). Taken from https://jsfiddle.net/6e17oxc3/
    */
    function initializeArrow(x, y) {
        var angle = Math.atan2(toy - fromy, tox - fromx);
        var headlen = 15;  // arrow head size
        // bring the line end back some to account for arrow head.
        tox = tox - (headlen) * Math.cos(angle);
        toy = toy - (headlen) * Math.sin(angle);
        // calculate the points.
        var points = [
            {
                x: fromx,  // start point
                y: fromy
            }, {
                x: fromx - (headlen / 4) * Math.cos(angle - Math.PI / 2),
                y: fromy - (headlen / 4) * Math.sin(angle - Math.PI / 2)
            },{
                x: tox - (headlen / 4) * Math.cos(angle - Math.PI / 2),
                y: toy - (headlen / 4) * Math.sin(angle - Math.PI / 2)
            }, {
                x: tox - (headlen) * Math.cos(angle - Math.PI / 2),
                y: toy - (headlen) * Math.sin(angle - Math.PI / 2)
            },{
                x: tox + (headlen) * Math.cos(angle),  // tip
                y: toy + (headlen) * Math.sin(angle)
            }, {
                x: tox - (headlen) * Math.cos(angle + Math.PI / 2),
                y: toy - (headlen) * Math.sin(angle + Math.PI / 2)
            }, {
                x: tox - (headlen / 4) * Math.cos(angle + Math.PI / 2),
                y: toy - (headlen / 4) * Math.sin(angle + Math.PI / 2)
            }, {
                x: fromx - (headlen / 4) * Math.cos(angle + Math.PI / 2),
                y: fromy - (headlen / 4) * Math.sin(angle + Math.PI / 2)
            },{
                x: fromx,
                y: fromy
            }
        ];

        var pline = new fabric.Polyline(points, {
            fill: 'white',
            stroke: 'black',
            opacity: 1,
            strokeWidth: 2,
            originX: 'left',
            originY: 'top',
            selectable: true
        });
        canvas.add(pline);
        canvas.renderAll();
    }

    function updateArrow(x, y) {

    }

    function calculateArrowPoints() {}


    //fabricJS mouse-down event listener
    overlay.fabricCanvas().observe('mouse:down', function(o){
         console.log("EVENT TRIGERRED: fabricjs-mouse:down");
         console.log("mouse mode is " + getMouseMode());
         if(getMouseMode()=="addAnnotation") {
             console.log("initializing circle!!!!!!!!!!!!!!!!!!!!!!!!");
             isDown = true;
             var pointer = overlay.fabricCanvas().getPointer(o.e);
             origX = pointer.x;
             origY = pointer.y;
             // initializeCircle(pointer.x, pointer.y);
             // initializeRectangle(pointer.x, pointer.y);
             // initializeLine(pointer.x, pointer.y);
             initializeEllipse(pointer.x, pointer.y);
             // initializeText(pointer.x, pointer.y);
         }
    });

    //fabricJS mouse-move event listener
    overlay.fabricCanvas().observe('mouse:move', function(o){
         console.log("EVENT TRIGERRED: fabricjs-mouse:move");
         if (!isDown) return;
         var pointer = overlay.fabricCanvas().getPointer(o.e);
         // updateCircleRadius(pointer.x, pointer.y, origX, origY); //do I need to pass this or can I access it as a member? in general, need to clarify b/w member obj.
         // updateRectangleWidth(pointer.x, pointer.y, origX, origY);
         // updateLineEndpoint(pointer.x, pointer.y);
         updateEllipse(pointer.x, pointer.y);
         // updateTextContent(pointer.x, pointer.y);
         overlay.fabricCanvas().renderAll();
    });

    //fabricJS mouse-up event listener
    overlay.fabricCanvas().on('mouse:up', function(o){
        console.log("EVENT TRIGERRED: fabricj-mouse:up");
        if(getMouseMode()=="addAnnotation") {
            setMouseMode("OSD");
        }
        isDown = false;
        console.log(serializeToJSON());
    });

    //OSD event listener. Currently not really used.
    viewer.addHandler('canvas-click', function(event) {
        var pointer = overlay.fabricCanvas().getPointer(event.e);
        console.log("EVENT TRIGERRED: OSD-canvas-click")
    });

    //Toggle map scrolling button.
    $("#toggleMapScrolling").click(function() {
        console.log("toggle dat map scrolling boi");
        viewer.setMouseNavEnabled(false);
        setMouseMode("addAnnotation");
    })

    $("input[name='cursorMode']").change(function() {
        console.log("cursorMode change detected: " + $("input[name='cursorMode']:checked").val());
        var mode1 = $("input[name='cursorMode']").val();
        mode1="addAnnotation";
        setMouseMode(mode1);
    });

    $("input[name='annotationShape']").change(function(){
        console.log("annotationShape change detected: " + $("input[name='annotationShape']:checked").val());

    });

    $("#addAnnotation").click(function() {
        setMouseMode("addAnnotation");
    });

    function setMouseMode(mode) {
        switch(mode) {
            case "OSD":
                console.log("mousemode: OSD");
            mouseMode="OSD";
                viewer.setMouseNavEnabled(true);
                break;
            case "addAnnotation":
                console.log("mousemode: addAnnotation");
                mouseMode="addAnnotation";
                viewer.setMouseNavEnabled(false); //if we're in addAnnotation mode, don't set isDown to true -- actually, ONLY set to true if mode is addAnnotation
                break;
            case "editAnnotation":
                console.log("mousemode: editAnnotation");
                mouseMode="editAnnotation";
                break;
            default:
                console.log(mode);
                throw "Tried to set invalid mouse mode";
        }
    }

    function getMouseMode(){
        return mouseMode;
    }



    /*************************/
    /* Might be useful later */
    /*************************/


    //create a new rectangle and add to canvas
    function addRectToCanvas(x, y) {
        var rect = new fabric.Rect({
            left: x,
            top: y,
            fill: 'blue',
            width: 1000,
            height: 1000
        });
        overlay.fabricCanvas().add(rect);
        overlay.fabricCanvas().renderAll();
    }

    //create a new circle and add it to canvas
    function addCircleToCanvas(x, y) {
        var circle = new fabric.Circle({
            left: x,
            top: y,
            radius: 225,
            strokeWidth: 1,
            stroke: 'black',
            fill: 'white',
            selectable: true,
            originX: 'center', originY: 'center'
        });
        overlay.fabricCanvas().add(circle);
        overlay.fabricCanvas().renderAll();
    }

    function serializeToJSON() {
        console.log("attempting to serialize");
        console.log(overlay.fabricCanvas().toJSON());

        $.ajax({
            type: "POST",
            url: "{% url 'xgds_image_save_annotations' %}",
            data: overlay.fabricCanvas().toJSON(),
            contentType: 'application/json; charset=utf-8'
        }).done(function (response) {
            location.reload(true);
        })

        // $.ajax({
        //     url: url,
        //     type: "POST",
        //     data: JSON.stringify(data),
        //     processData: false,
        //     contentType: "application/json; charset=UTF-8",
        //     complete: callback
        // });
    }

    //need to pass in JSON string
    function deserializeFromJSON(json) {
        overlay.fabricCanvas().loadFromJSON(json);
    }

/* TODO:
mouse modes
serialization
color pallete
xgds ref


 */
     {% endblock jsInit %}

